#!/usr/bin/env node
require('dotenv').config();
const { Client } = require('pg');

const AMOUNT_MIN_WIDTH = 12;
const COLUMN_SEPARATOR = ' | ';
const COMMANDS = [
  'add AMOUNT MEMO [DATE] - record a new expense',
  'clear - delete all expenses',
  'list - list all expenses',
  'delete NUMBER - remove expenses with id NUMBER',
  'search QUERY - list expenses with a matching memo field',
];

function logAndExit(rejectedPromise) {
  console.error(rejectedPromise);
  process.exit(1);
}

function showHelp() {
  const help = 'An expense recording system \n\nCommands:\n\n' + COMMANDS.join('\n');
  console.log(help);
}

function normalizeCellWidths(data) {
  // for each column, get the width of the widest cell
  Object.keys(data.rows[0]).map((key) => {
    // reduce over column, returning the max length
    const maxWidth = data.rows
    .reduce((max, current) => max < current[key].length ? current[key].length : max, '');
    // pad the start of all column cells to match the widest
    data.rows.forEach((row) => {
      row[key] = String(row[key]).padStart(maxWidth, ' ');
    });
  });
}

function getFormattedRows(data) {
  // transform rows into formatted strings
  normalizeCellWidths(data);
  // order fields and concatenate row values
  const displayRows = data.rows.map((row) => {
    const formattedDate = new Date(row.created_on).toDateString();
    const formattedAmount = row.amount.padStart(AMOUNT_MIN_WIDTH, ' ');
    const orderedRow = [row.id, formattedDate, formattedAmount, row.memo];    
    return orderedRow.join(COLUMN_SEPARATOR);
  });

  return displayRows;
}

async function logQuery (queryString) {
  const client = new Client();
  let data;
  await client.connect().catch(logAndExit);
  data = await client.query(queryString).catch(logAndExit);
  await client.end().catch(logAndExit);

  const displayRows = getFormattedRows(data);
  displayRows.forEach((displayRow) => console.log(displayRow));
  await client.end();
}

function listExpenses() {
  logQuery('SELECT * FROM expenses ORDER BY created_on ASC');
}

async function AddExpense({ amount, memo, date = new Date() }) {
  const client = new Client();
  const formattedDate = date.toLocaleDateString();
  await client.connect().catch(logAndExit);
  const success = await client.query(
    'INSERT INTO expenses (amount, memo, created_on) VALUES ($1, $2, $3)',
    [amount, memo, formattedDate]
  ).catch(logAndExit);
  // console.log({ success: Array.isArray(success.rows) });
  await client.end().catch(logAndExit);
}

function addExpenseInput() {
  const [amount, memo, date] = process.argv.slice(3, 6);
  if (!amount || !memo) {
    console.log('You must provide an amount and memo.');
  } else {
    AddExpense({ amount, memo, date });
  }
}

(() => {
  const operation = process.argv[2];
  
  const OPERATION_MAP = {
    list: listExpenses,
    add: addExpenseInput,
  }

  if (!operation) {
    showHelp();  
  } else if (operation in OPERATION_MAP) {
    OPERATION_MAP[operation]();
  } else {
    console.log('Argument unrecognized');
  }
})();
